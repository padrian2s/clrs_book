{
  "page": 638,
  "title": "23.2 The Algorithms of Kruskal and Prim",
  "content": "<div class=\"article-header\">\n    <div class=\"section-label\">Section 23.2</div>\n    <h1>The Algorithms of Kruskal and Prim</h1>\n</div>\n<div class=\"original-content\">\n    <div class=\"definition-box\">\n        <h4>Summary</h4>\n        <p><strong>Two efficient algorithms for finding minimum spanning trees.</strong></p>\n    </div>\n\n    <div class=\"highlight-box\">\n        <h4>Key Points</h4>\n        <ul><li>Kruskal: sort edges by weight, add if doesn&#x27;t create cycle</li>\n<li>Use Union-Find to detect cycles efficiently</li>\n<li>Kruskal time: O(E log E) = O(E log V)</li>\n<li>Prim: grow tree from single vertex, always add lightest edge to tree</li>\n<li>Prim with binary heap: O(E log V). With Fibonacci heap: O(E + V log V)</li></ul>\n    </div>\n\n    <div class=\"algorithm\">\n    <h4>Pseudocode</h4>\n    <pre style=\"font-size: 0.85rem; line-height: 1.6;\">MST-KRUSKAL(G, w):\n    A = ∅\n    for each vertex v: MAKE-SET(v)\n    sort edges by weight\n    for each edge (u,v) in sorted order:\n        if FIND-SET(u) ≠ FIND-SET(v):\n            A = A ∪ {(u,v)}\n            UNION(u, v)\n    return A\n\nMST-PRIM(G, w, r):\n    for each u: key[u] = ∞, π[u] = NIL\n    key[r] = 0\n    Q = V  # min-priority queue\n    while Q not empty:\n        u = EXTRACT-MIN(Q)\n        for each v adjacent to u:\n            if v ∈ Q and w(u,v) &lt; key[v]:\n                π[v] = u\n                key[v] = w(u,v)</pre>\n</div>\n    \n    <div class=\"highlight-box\">\n    <h4>Why It Matters</h4>\n    <p>Network design, clustering, approximation algorithms.</p>\n</div>\n</div>"
}