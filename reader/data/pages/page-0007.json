{
  "page": 7,
  "title": "Table of Contents",
  "content": "<div class=\"article-header\">\n    <div class=\"section-label\">Navigation</div>\n    <h1>Table of Contents</h1>\n</div>\n<div class=\"original-content\">\n    <pre style=\"font-family: var(--font-sans); font-size: 0.85rem; line-height: 1.8; white-space: pre-wrap;\">\nPART I: FOUNDATIONS\n  1. The Role of Algorithms in Computing (p.5)\n     1.1 Algorithms - What is an algorithm? The sorting problem\n     1.2 Algorithms as a technology - Efficiency matters\n\n  2. Getting Started (p.16)\n     2.1 Insertion sort - Your first algorithm\n     2.2 Analyzing algorithms - How to measure performance\n     2.3 Designing algorithms - Divide-and-conquer, merge sort\n\n  3. Growth of Functions (p.43)\n     3.1 Asymptotic notation - O, Θ, Ω explained\n     3.2 Standard notations - Floors, ceilings, logs, factorials\n\n  4. Divide-and-Conquer (p.65)\n     4.1 Maximum-subarray problem\n     4.2 Strassen's matrix multiplication\n     4.3-4.5 Solving recurrences - Substitution, recursion trees, master method\n\n  5. Probabilistic Analysis (p.114)\n     5.1 The hiring problem\n     5.2 Indicator random variables\n     5.3 Randomized algorithms\n\nPART II: SORTING AND ORDER STATISTICS\n  6. Heapsort (p.151)\n     6.1 Heaps - The heap data structure\n     6.2 Maintaining heap property - MAX-HEAPIFY\n     6.3 Building a heap - BUILD-MAX-HEAP\n     6.4 Heapsort algorithm\n     6.5 Priority queues\n\n  7. Quicksort (p.170)\n     7.1 Description - PARTITION and QUICKSORT\n     7.2 Performance analysis\n     7.3 Randomized quicksort\n     7.4 Analysis of quicksort\n\n  8. Sorting in Linear Time (p.191)\n     8.1 Lower bounds - Ω(n lg n) for comparison sorts\n     8.2 Counting sort\n     8.3 Radix sort\n     8.4 Bucket sort\n\n  9. Medians and Order Statistics (p.213)\n     9.1 Minimum and maximum\n     9.2 Selection in expected linear time\n     9.3 Selection in worst-case linear time\n\nPART III: DATA STRUCTURES\n  10. Elementary Data Structures (p.232)\n      10.1 Stacks and queues\n      10.2 Linked lists\n      10.3 Implementing pointers and objects\n      10.4 Representing rooted trees\n\n  11. Hash Tables (p.253)\n      11.1 Direct-address tables\n      11.2 Hash tables - Chaining\n      11.3 Hash functions\n      11.4 Open addressing\n\n  12. Binary Search Trees (p.286)\n      12.1 What is a BST?\n      12.2 Querying - Search, Min, Max, Successor\n      12.3 Insertion and deletion\n\n  13. Red-Black Trees (p.308)\n      13.1 Properties of red-black trees\n      13.2 Rotations\n      13.3 Insertion\n      13.4 Deletion\n\n  14. Augmenting Data Structures (p.339)\n      14.1 Dynamic order statistics\n      14.2 How to augment a data structure\n      14.3 Interval trees\n\nPART IV: ADVANCED DESIGN AND ANALYSIS TECHNIQUES\n  15. Dynamic Programming (p.359)\n      15.1 Rod cutting\n      15.2 Matrix-chain multiplication\n      15.3 Elements of DP - Optimal substructure, overlapping subproblems\n      15.4 Longest common subsequence\n      15.5 Optimal binary search trees\n\n  16. Greedy Algorithms (p.414)\n      16.1 Activity-selection problem\n      16.2 Elements of greedy strategy\n      16.3 Huffman codes\n\n  17. Amortized Analysis (p.451)\n      17.1 Aggregate analysis\n      17.2 Accounting method\n      17.3 Potential method\n      17.4 Dynamic tables\n\nPART V: ADVANCED DATA STRUCTURES\n  18. B-Trees (p.484)\n  19. Fibonacci Heaps (p.505)\n  20. van Emde Boas Trees (p.531)\n  21. Data Structures for Disjoint Sets (p.561)\n\nPART VI: GRAPH ALGORITHMS\n  22. Elementary Graph Algorithms (p.589)\n      22.1 Representations - Adjacency list vs matrix\n      22.2 Breadth-first search (BFS)\n      22.3 Depth-first search (DFS)\n      22.4 Topological sort\n      22.5 Strongly connected components\n\n  23. Minimum Spanning Trees (p.624)\n      23.1 Growing a MST\n      23.2 Kruskal and Prim algorithms\n\n  24. Single-Source Shortest Paths (p.643)\n      24.1 Bellman-Ford algorithm\n      24.2 Shortest paths in DAGs\n      24.3 Dijkstra's algorithm\n\n  25. All-Pairs Shortest Paths (p.684)\n      25.1 Matrix multiplication method\n      25.2 Floyd-Warshall algorithm\n      25.3 Johnson's algorithm\n\n  26. Maximum Flow (p.708)\n      26.1 Flow networks\n      26.2 Ford-Fulkerson method\n      26.3 Maximum bipartite matching\n\nPART VII: SELECTED TOPICS\n  27. Multithreaded Algorithms (p.772)\n  28. Matrix Operations (p.813)\n  29. Linear Programming (p.843)\n  30. Polynomials and the FFT (p.898)\n  31. Number-Theoretic Algorithms (p.926)\n  32. String Matching (p.985)\n  33. Computational Geometry (p.1014)\n  34. NP-Completeness (p.1048)\n  35. Approximation Algorithms (p.1106)\n\nPART VIII: APPENDIX\n  A. Summations (p.1145)\n  B. Sets, Relations, Functions, Graphs, Trees (p.1158)\n  C. Counting and Probability (p.1183)\n  D. Matrices (p.1217)\n</pre>\n</div>\n<div class=\"analysis-section\">\n    <h3>How to Navigate</h3>\n    <div class=\"analysis-block\">\n        <div class=\"analysis-item\">\n            <h5>Keyboard Shortcuts</h5>\n            <ul>\n                <li><kbd>←</kbd> <kbd>→</kbd> Previous/Next page</li>\n                <li><kbd>G</kbd> Go to specific page</li>\n                <li><kbd>V</kbd> Toggle image/text view</li>\n                <li><kbd>+</kbd> <kbd>-</kbd> Zoom in/out</li>\n                <li><kbd>1-8</kbd> Zoom levels (70%-140%)</li>\n                <li><kbd>Home</kbd> <kbd>End</kbd> First/Last page</li>\n            </ul>\n        </div>\n    </div>\n</div>"
}