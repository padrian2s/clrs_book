20.2 A recursive structure                                                            537


If we use the same technique, changing variables, we can show that recur-
rence (20.2) has the solution T .u/ D O.lg lg u/. Let m D lg u, so that u D 2m
and we have
T .2m / D T .2m=2 / C O.1/ :
Now we rename S.m/ D T .2m /, giving the new recurrence
S.m/ D S.m=2/ C O.1/ :
By case 2 of the master method, this recurrence has the solution S.m/ D O.lg m/.
We change back from S.m/ to T .u/, giving T .u/ D T .2m / D S.m/ D O.lg m/ D
O.lg lg u/.
   Recurrence (20.2) will guide our search for a data   p structure. We will design a
recursive data structure that shrinks by a factor of u in each level of its recursion.
When an operation traverses this data structure, it will spend a constant amount of
time at each level before recursing to the level below. Recurrence (20.2) will then
characterize the running time of the operation.
   Here is another way to think of how the term lg lg u ends up in the solution to
recurrence (20.2). As we look at the universe size in each level of the recursive data
structure, we see the sequence u; u1=2 ; u1=4 ; u1=8 ; : : :. If we consider how many bits
we need to store the universe size at each level, we need lg u at the top level, and
each level needs half the bits of the previous level. In general, if we start with b
bits and halve the number of bits at each level, then after lg b levels, we get down
to just one bit. Since b D lg u, we see that after lg lg u levels, we have a universe
size of 2.
   Looking back at p  the data structure in Figure 20.2, a given value x resides in
cluster numberp   bx=   uc. If we view x as a lg u-bit binary integer, that cluster
number, bx= uc, is given by the most    p signiﬁcant .lg u/=2 bits of x. Within its
cluster, x appears in position x mod u, which is given by the least signiﬁcant
.lg u/=2 bits of x. We will need to index in this way, and so let us deﬁne some
functions that will help us do so:
                        p ˘
    high.x/ D x= u ;
                           p
     low.x/ D x mod u ;
                     p
index.x; y/ D x u C y :
The function high.x/ gives the most signiﬁcant .lg u/=2 bits of x, producing the
number of x’s cluster. The function low.x/ gives the least signiﬁcant .lg u/=2 bits
of x and provides x’s position within its cluster. The function index.x; y/ builds an
element number from x and y, treating x as the most signiﬁcant .lg u/=2 bits of the
element number and y as the least signiﬁcant .lg u/=2 bits. We have the identity
x D index.high.x/; low.x//. The value of u used by each of these functions will
