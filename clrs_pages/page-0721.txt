700         Chapter 25 All-Pairs Shortest Paths


            25.2-6
            How can we use the output of the Floyd-Warshall algorithm to detect the presence
            of a negative-weight cycle?

            25.2-7
            Another way to reconstruct shortest paths in the Floyd-Warshall algorithm uses
            values ij.k/ for i; j; k D 1; 2; : : : ; n, where ij.k/ is the highest-numbered interme-
            diate vertex of a shortest path from i to j in which all intermediate vertices are
            in the set f1; 2; : : : ; kg. Give a recursive formulation for ij.k/ , modify the F LOYD -
            WARSHALL procedure to compute the ij.k/ values, and rewrite the P RINT-A LL -
            PAIRS -S HORTEST-PATH procedure to take the matrix ˆ D ij.n/ as an input.
            How is the matrix ˆ like the s table in the matrix-chain multiplication problem of
            Section 15.2?

            25.2-8
            Give an O.VE/-time algorithm for computing the transitive closure of a directed
            graph G D .V; E/.

            25.2-9
            Suppose that we can compute the transitive closure of a directed acyclic graph in
            f .jV j ; jEj/ time, where f is a monotonically increasing function of jV j and jEj.
            Show that the time to compute the transitive closure G  D .V; E  / of a general
            directed graph G D .V; E/ is then f .jV j ; jEj/ C O.V C E  /.



25.3 Johnson’s algorithm for sparse graphs

            Johnson’s algorithm ﬁnds shortest paths between all pairs in O.V 2 lg V C VE/
            time. For sparse graphs, it is asymptotically faster than either repeated squaring of
            matrices or the Floyd-Warshall algorithm. The algorithm either returns a matrix of
            shortest-path weights for all pairs of vertices or reports that the input graph contains
            a negative-weight cycle. Johnson’s algorithm uses as subroutines both Dijkstra’s
            algorithm and the Bellman-Ford algorithm, which Chapter 24 describes.
               Johnson’s algorithm uses the technique of reweighting, which works as follows.
            If all edge weights w in a graph G D .V; E/ are nonnegative, we can ﬁnd short-
            est paths between all pairs of vertices by running Dijkstra’s algorithm once from
            each vertex; with the Fibonacci-heap min-priority queue, the running time of this
            all-pairs algorithm is O.V 2 lg V C VE/. If G has negative-weight edges but no
            negative-weight cycles, we simply compute a new set of nonnegative edge weights
