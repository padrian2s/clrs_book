662   Chapter 24 Single-Source Shortest Paths


      queue by taking advantage of the vertices being numbered 1 to jV j. We simply
      store :d in the th entry of an array. Each I NSERT and D ECREASE -K EY operation
      takes O.1/ time, and each E XTRACT-M IN operation takes O.V / time (since we
      have to search through the entire array), for a total time of O.V 2 C E/ D O.V 2 /.
         If the graph is sufﬁciently sparse—in particular, E D o.V 2 = lg V /—we can
      improve the algorithm by implementing the min-priority queue with a binary min-
      heap. (As discussed in Section 6.5, the implementation should make sure that
      vertices and corresponding heap elements maintain handles to each other.) Each
      E XTRACT-M IN operation then takes time O.lg V /. As before, there are jV j such
      operations. The time to build the binary min-heap is O.V /. Each D ECREASE -K EY
      operation takes time O.lg V /, and there are still at most jEj such operations. The
      total running time is therefore O..V C E/ lg V /, which is O.E lg V / if all vertices
      are reachable from the source. This running time improves upon the straightfor-
      ward O.V 2 /-time implementation if E D o.V 2 = lg V /.
         We can in fact achieve a running time of O.V lg V C E/ by implementing the
      min-priority queue with a Fibonacci heap (see Chapter 19). The amortized cost
      of each of the jV j E XTRACT-M IN operations is O.lg V /, and each D ECREASE -
      K EY call, of which there are at most jEj, takes only O.1/ amortized time. His-
      torically, the development of Fibonacci heaps was motivated by the observation
      that Dijkstra’s algorithm typically makes many more D ECREASE -K EY calls than
      E XTRACT-M IN calls, so that any method of reducing the amortized time of each
      D ECREASE -K EY operation to o.lg V / without increasing the amortized time of
      E XTRACT-M IN would yield an asymptotically faster implementation than with bi-
      nary heaps.
         Dijkstra’s algorithm resembles both breadth-ﬁrst search (see Section 22.2) and
      Prim’s algorithm for computing minimum spanning trees (see Section 23.2). It is
      like breadth-ﬁrst search in that set S corresponds to the set of black vertices in a
      breadth-ﬁrst search; just as vertices in S have their ﬁnal shortest-path weights, so
      do black vertices in a breadth-ﬁrst search have their correct breadth-ﬁrst distances.
      Dijkstra’s algorithm is like Prim’s algorithm in that both algorithms use a min-
      priority queue to ﬁnd the “lightest” vertex outside a given set (the set S in Dijkstra’s
      algorithm and the tree being grown in Prim’s algorithm), add this vertex into the
      set, and adjust the weights of the remaining vertices outside the set accordingly.

      Exercises

      24.3-1
      Run Dijkstra’s algorithm on the directed graph of Figure 24.2, ﬁrst using vertex s
      as the source and then using vertex ´ as the source. In the style of Figure 24.6,
      show the d and  values and the vertices in set S after each iteration of the while
      loop.
