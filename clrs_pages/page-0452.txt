16.3 Huffman codes                                                                 431


of c’s leaf in the tree. Note that dT .c/ is also the length of the codeword for
character c. The number of bits required to encode a ﬁle is thus
         X
B.T / D       c:freq  dT .c/ ;                                           (16.4)
         c2C

which we deﬁne as the cost of the tree T .

Constructing a Huffman code
Huffman invented a greedy algorithm that constructs an optimal preﬁx code called
a Huffman code. In line with our observations in Section 16.2, its proof of cor-
rectness relies on the greedy-choice property and optimal substructure. Rather
than demonstrating that these properties hold and then developing pseudocode, we
present the pseudocode ﬁrst. Doing so will help clarify how the algorithm makes
greedy choices.
   In the pseudocode that follows, we assume that C is a set of n characters and
that each character c 2 C is an object with an attribute c:freq giving its frequency.
The algorithm builds the tree T corresponding to the optimal code in a bottom-up
manner. It begins with a set of jC j leaves and performs a sequence of jC j  1
“merging” operations to create the ﬁnal tree. The algorithm uses a min-priority
queue Q, keyed on the freq attribute, to identify the two least-frequent objects to
merge together. When we merge two objects, the result is a new object whose
frequency is the sum of the frequencies of the two objects that were merged.

H UFFMAN .C /
1 n D jC j
2 QDC
3 for i D 1 to n  1
4      allocate a new node ´
5      ´:left D x D E XTRACT-M IN .Q/
6      ´:right D y D E XTRACT-M IN .Q/
7      ´:freq D x:freq C y:freq
8      I NSERT .Q; ´/
9 return E XTRACT-M IN .Q/      // return the root of the tree

For our example, Huffman’s algorithm proceeds as shown in Figure 16.5. Since
the alphabet contains 6 letters, the initial queue size is n D 6, and 5 merge steps
build the tree. The ﬁnal tree represents the optimal preﬁx code. The codeword for
a letter is the sequence of edge labels on the simple path from the root to the letter.
   Line 2 initializes the min-priority queue Q with the characters in C . The for
loop in lines 3–8 repeatedly extracts the two nodes x and y of lowest frequency
