34.3 NP-completeness and reducibility                                                          1073


the size of C is polynomial in k, checking each one takes .2k / time, which is
superpolynomial in the size of the circuit.9 In fact, as we have claimed, there is
strong evidence that no polynomial-time algorithm exists that solves the circuit-
satisﬁability problem because circuit satisﬁability is NP-complete. We break the
proof of this fact into two parts, based on the two parts of the deﬁnition of NP-
completeness.

Lemma 34.5
The circuit-satisﬁability problem belongs to the class NP.

Proof We shall provide a two-input, polynomial-time algorithm A that can verify
CIRCUIT-SAT. One of the inputs to A is (a standard encoding of) a boolean com-
binational circuit C . The other input is a certiﬁcate corresponding to an assignment
of boolean values to the wires in C . (See Exercise 34.3-4 for a smaller certiﬁcate.)
   We construct the algorithm A as follows. For each logic gate in the circuit, it
checks that the value provided by the certiﬁcate on the output wire is correctly
computed as a function of the values on the input wires. Then, if the output of the
entire circuit is 1, the algorithm outputs 1, since the values assigned to the inputs
of C provide a satisfying assignment. Otherwise, A outputs 0.
   Whenever a satisﬁable circuit C is input to algorithm A, there exists a certiﬁcate
whose length is polynomial in the size of C and that causes A to output a 1. When-
ever an unsatisﬁable circuit is input, no certiﬁcate can fool A into believing that
the circuit is satisﬁable. Algorithm A runs in polynomial time: with a good imple-
mentation, linear time sufﬁces. Thus, we can verify CIRCUIT-SAT in polynomial
time, and CIRCUIT-SAT 2 NP.

   The second part of proving that CIRCUIT-SAT is NP-complete is to show that
the language is NP-hard. That is, we must show that every language in NP is
polynomial-time reducible to CIRCUIT-SAT. The actual proof of this fact is full
of technical intricacies, and so we shall settle for a sketch of the proof based on
some understanding of the workings of computer hardware.
   A computer program is stored in the computer memory as a sequence of in-
structions. A typical instruction encodes an operation to be performed, addresses
of operands in memory, and an address where the result is to be stored. A spe-
cial memory location, called the program counter, keeps track of which instruc-


9 On the other hand, if the size of the circuit C is ‚.2k /, then an algorithm whose running time

is O.2k / has a running time that is polynomial in the circuit size. Even if P ¤ NP, this situa-
tion would not contradict the NP-completeness of the problem; the existence of a polynomial-time
algorithm for a special case does not imply that there is a polynomial-time algorithm for all cases.
