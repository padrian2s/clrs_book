986   Chapter 32 String Matching



      Algorithm            Preprocessing time     Matching time
      Naive                        0            O..n  m C 1/m/
      Rabin-Karp                 ‚.m/           O..n  m C 1/m/
      Finite automaton          O.m j†j/             ‚.n/
      Knuth-Morris-Pratt         ‚.m/                ‚.n/


      Figure 32.2 The string-matching algorithms in this chapter and their preprocessing and matching
      times.


         Except for the naive brute-force algorithm, which we review in Section 32.1,
      each string-matching algorithm in this chapter performs some preprocessing based
      on the pattern and then ﬁnds all valid shifts; we call this latter phase “matching.”
      Figure 32.2 shows the preprocessing and matching times for each of the algorithms
      in this chapter. The total running time of each algorithm is the sum of the prepro-
      cessing and matching times. Section 32.2 presents an interesting string-matching
      algorithm, due to Rabin and Karp. Although the ‚..n  m C 1/m/ worst-case
      running time of this algorithm is no better than that of the naive method, it works
      much better on average and in practice. It also generalizes nicely to other pattern-
      matching problems. Section 32.3 then describes a string-matching algorithm that
      begins by constructing a ﬁnite automaton speciﬁcally designed to search for occur-
      rences of the given pattern P in a text. This algorithm takes O.m j†j/ preprocess-
      ing time, but only ‚.n/ matching time. Section 32.4 presents the similar, but much
      cleverer, Knuth-Morris-Pratt (or KMP) algorithm; it has the same ‚.n/ matching
      time, and it reduces the preprocessing time to only ‚.m/.

      Notation and terminology
      We denote by † (read “sigma-star”) the set of all ﬁnite-length strings formed
      using characters from the alphabet †. In this chapter, we consider only ﬁnite-
      length strings. The zero-length empty string, denoted ", also belongs to † . The
      length of a string x is denoted jxj. The concatenation of two strings x and y,
      denoted xy, has length jxj C jyj and consists of the characters from x followed by
      the characters from y.
         We say that a string w is a preﬁx of a string x, denoted w < x, if x D wy for
      some string y 2 † . Note that if w < x, then jwj  jxj. Similarly, we say that a
      string w is a sufﬁx of a string x, denoted w = x, if x D yw for some y 2 † . As
      with a preﬁx, w = x implies jwj  jxj. For example, we have ab < abcca and
      cca = abcca. The empty string " is both a sufﬁx and a preﬁx of every string. For
      any strings x and y and any character a, we have x = y if and only if xa = ya.
