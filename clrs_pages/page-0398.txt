15.2 Matrix-chain multiplication                                                    377


northwest from Aj . Each horizontal row in the table contains the entries for matrix
chains of the same length. M ATRIX -C HAIN -O RDER computes the rows from bot-
tom to top and from left to right within each row. It computes each entry mŒi; j 
using the products pi 1 pk pj for k D i; i C 1; : : : ; j  1 and all entries southwest
and southeast from mŒi; j .
   A simple inspection of the nested loop structure of M ATRIX -C HAIN -O RDER
yields a running time of O.n3 / for the algorithm. The loops are nested three deep,
and each loop index (l, i, and k) takes on at most n1 values. Exercise 15.2-5 asks
you to show that the running time of this algorithm is in fact also .n3 /. The al-
gorithm requires ‚.n2 / space to store the m and s tables. Thus, M ATRIX -C HAIN -
O RDER is much more efﬁcient than the exponential-time method of enumerating
all possible parenthesizations and checking each one.

Step 4: Constructing an optimal solution
Although M ATRIX -C HAIN -O RDER determines the optimal number of scalar mul-
tiplications needed to compute a matrix-chain product, it does not directly show
how to multiply the matrices. The table sŒ1 : : n  1; 2 : : n gives us the informa-
tion we need to do so. Each entry sŒi; j  records a value of k such that an op-
timal parenthesization of Ai Ai C1    Aj splits the product between Ak and AkC1 .
Thus, we know that the ﬁnal matrix multiplication in computing A1::n optimally
is A1::sŒ1;n AsŒ1;nC1::n . We can determine the earlier matrix multiplications recur-
sively, since sŒ1; sŒ1; n determines the last matrix multiplication when computing
A1::sŒ1;n and sŒsŒ1; n C 1; n determines the last matrix multiplication when com-
puting AsŒ1;nC1::n . The following recursive procedure prints an optimal parenthe-
sization of hAi ; Ai C1 ; : : : ; Aj i, given the s table computed by M ATRIX -C HAIN -
O RDER and the indices i and j . The initial call P RINT-O PTIMAL -PARENS .s; 1; n/
prints an optimal parenthesization of hA1 ; A2 ; : : : ; An i.

P RINT-O PTIMAL -PARENS .s; i; j /
1 if i == j
2      print “A”i
3 else print “(”
4       P RINT-O PTIMAL -PARENS .s; i; sŒi; j /
5       P RINT-O PTIMAL -PARENS .s; sŒi; j  C 1; j /
6      print “)”

In the example of Figure 15.5, the call P RINT-O PTIMAL -PARENS .s; 1; 6/ prints
the parenthesization ..A1 .A2 A3 //..A4 A5 /A6 //.
