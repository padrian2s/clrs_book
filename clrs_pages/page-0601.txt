580   Chapter 21 Data Structures for Disjoint Sets


         Because y is a root prior to the L INK, q1 .y/ D ˛.n/  y:rank. The L INK
          operation leaves y as a root, and it either leaves y’s rank alone or it increases y’s
          rank by 1. Therefore, either q .y/ D q1 .y/ or q .y/ D q1 .y/ C ˛.n/.
        The increase in potential due to the L INK operation, therefore, is at most ˛.n/.
      The amortized cost of the L INK operation is O.1/ C ˛.n/ D O.˛.n//.

      Lemma 21.13
      The amortized cost of each F IND -S ET operation is O.˛.n//.

      Proof Suppose that the qth operation is a F IND -S ET and that the ﬁnd path con-
      tains s nodes. The actual cost of the F IND -S ET operation is O.s/. We shall
      show that no node’s potential increases due to the F IND -S ET and that at least
      max.0; s  .˛.n/ C 2// nodes on the ﬁnd path have their potential decrease by
      at least 1.
         To see that no node’s potential increases, we ﬁrst appeal to Lemma 21.10 for all
      nodes other than the root. If x is the root, then its potential is ˛.n/  x:rank, which
      does not change.
         Now we show that at least max.0; s  .˛.n/ C 2// nodes have their potential
      decrease by at least 1. Let x be a node on the ﬁnd path such that x:rank > 0
      and x is followed somewhere on the ﬁnd path by another node y that is not a root,
      where level.y/ D level.x/ just before the F IND -S ET operation. (Node y need not
      immediately follow x on the ﬁnd path.) All but at most ˛.n/ C 2 nodes on the ﬁnd
      path satisfy these constraints on x. Those that do not satisfy them are the ﬁrst node
      on the ﬁnd path (if it has rank 0), the last node on the path (i.e., the root), and the
      last node w on the path for which level.w/ D k, for each k D 0; 1; 2; : : : ; ˛.n/ 1.
         Let us ﬁx such a node x, and we shall show that x’s potential decreases by at
      least 1. Let k D level.x/ D level.y/. Just prior to the path compression caused by
      the F IND -S ET, we have
      x:p:rank  A.iter.x//
                  k         .x:rank/ (by deﬁnition of iter.x/) ,
      y:p:rank  Ak .y:rank/         (by deﬁnition of level.y/) ,
        y:rank  x:p:rank            (by Corollary 21.5 and because
                                          y follows x on the ﬁnd path) .
      Putting these inequalities together and letting i be the value of iter.x/ before path
      compression, we have
      y:p:rank  Ak .y:rank/
                Ak .x:p:rank/                (because Ak .j / is strictly increasing)
                       Ak .A.iter.x//
                              k        .x:rank//
                         .i C1/
                   D    Ak .x:rank/ :
