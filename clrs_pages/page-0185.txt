164   Chapter 6 Heapsort


      the procedure then, in a manner reminiscent of the insertion loop (lines 5–7) of
      I NSERTION -S ORT from Section 2.1, traverses a simple path from this node toward
      the root to ﬁnd a proper place for the newly increased key. As H EAP -I NCREASE -
      K EY traverses this path, it repeatedly compares an element to its parent, exchang-
      ing their keys and continuing if the element’s key is larger, and terminating if the el-
      ement’s key is smaller, since the max-heap property now holds. (See Exercise 6.5-5
      for a precise loop invariant.)

      H EAP -I NCREASE -K EY .A; i; key/
      1 if key < AŒi
      2        error “new key is smaller than current key”
      3 AŒi D key
      4 while i > 1 and AŒPARENT.i/ < AŒi
      5        exchange AŒi with AŒPARENT.i/
      6        i D PARENT.i/

      Figure 6.5 shows an example of a H EAP -I NCREASE -K EY operation. The running
      time of H EAP -I NCREASE -K EY on an n-element heap is O.lg n/, since the path
      traced from the node updated in line 3 to the root has length O.lg n/.
         The procedure M AX -H EAP -I NSERT implements the I NSERT operation. It takes
      as an input the key of the new element to be inserted into max-heap A. The proce-
      dure ﬁrst expands the max-heap by adding to the tree a new leaf whose key is 1.
      Then it calls H EAP -I NCREASE -K EY to set the key of this new node to its correct
      value and maintain the max-heap property.

      M AX -H EAP -I NSERT .A; key/
      1 A:heap-size D A:heap-size C 1
      2 AŒA:heap-size D 1
      3 H EAP -I NCREASE -K EY .A; A:heap-size; key/

      The running time of M AX -H EAP -I NSERT on an n-element heap is O.lg n/.
         In summary, a heap can support any priority-queue operation on a set of size n
      in O.lg n/ time.

      Exercises

      6.5-1
      Illustrate the operation of H EAP -E XTRACT-M AX on the heap A D h15; 13; 9; 5;
      12; 8; 7; 4; 0; 6; 2; 1i.
