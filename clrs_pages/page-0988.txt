31.8 Primality testing                                                            967


ﬁnement of this method that removes the small defect. Let ZC
                                                           n denote the nonzero
elements of Zn :
ZC
 n D f1; 2; : : : ; n  1g :

                     n D Zn .
If n is prime, then ZC      

   We say that n is a base-a pseudoprime if n is composite and
an1  1 .mod n/ :                                                            (31.40)
Fermat’s theorem (Theorem 31.31) implies that if n is prime, then n satisﬁes equa-
tion (31.40) for every a in ZCn . Thus, if we can ﬁnd any a 2 Zn such that n does
                                                                 C

not satisfy equation (31.40), then n is certainly composite. Surprisingly, the con-
verse almost holds, so that this criterion forms an almost perfect test for primality.
We test to see whether n satisﬁes equation (31.40) for a D 2. If not, we declare n
to be composite by returning COMPOSITE. Otherwise, we return PRIME, guessing
that n is prime (when, in fact, all we know is that n is either prime or a base-2
pseudoprime).
   The following procedure pretends in this manner to be checking the primality
of n. It uses the procedure M ODULAR -E XPONENTIATION from Section 31.6. We
assume that the input n is an odd integer greater than 2.

P SEUDOPRIME .n/
1 if M ODULAR -E XPONENTIATION .2; n  1; n/ 6 1 .mod n/
2      return COMPOSITE      // deﬁnitely
3 else return PRIME          // we hope!

This procedure can make errors, but only of one type. That is, if it says that n
is composite, then it is always correct. If it says that n is prime, however, then it
makes an error only if n is a base-2 pseudoprime.
   How often does this procedure err? Surprisingly rarely. There are only 22 values
of n less than 10,000 for which it errs; the ﬁrst four such values are 341, 561,
645, and 1105. We won’t prove it, but the probability that this program makes an
error on a randomly chosen ˇ-bit number goes to zero as ˇ ! 1. Using more
precise estimates due to Pomerance [279] of the number of base-2 pseudoprimes of
a given size, we may estimate that a randomly chosen 512-bit number that is called
prime by the above procedure has less than one chance in 1020 of being a base-2
pseudoprime, and a randomly chosen 1024-bit number that is called prime has less
than one chance in 1041 of being a base-2 pseudoprime. So if you are merely
trying to ﬁnd a large prime for some application, for all practical purposes you
almost never go wrong by choosing large numbers at random until one of them
causes P SEUDOPRIME to return PRIME. But when the numbers being tested for
primality are not randomly chosen, we need a better approach for testing primality.
