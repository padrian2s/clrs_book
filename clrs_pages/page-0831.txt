810   Chapter 27 Multithreaded Algorithms


      a stencil algorithm to compute a longest common subsequence, where the value in
      entry cŒi; j  depends only on the values in cŒi 1; j , cŒi; j 1, and cŒi 1; j 1,
      as well as the elements xi and yj within the two sequences given as inputs. The
      input sequences are ﬁxed, but the algorithm ﬁlls in the two-dimensional array c so
      that it computes entry cŒi; j  after computing all three entries cŒi 1; j , cŒi; j 1,
      and cŒi  1; j  1.
         In this problem, we examine how to use nested parallelism to multithread a
      simple stencil calculation on an n n array A in which, of the values in A, the
      value placed into entry AŒi; j  depends only on values in AŒi 0 ; j 0 , where i 0  i
      and j 0  j (and of course, i 0 ¤ i or j 0 ¤ j ). In other words, the value in an
      entry depends only on values in entries that are above it and/or to its left, along
      with static information outside of the array. Furthermore, we assume throughout
      this problem that once we have ﬁlled in the entries upon which AŒi; j  depends, we
      can ﬁll in AŒi; j  in ‚.1/ time (as in the LCS-L ENGTH procedure of Section 15.4).
         We can partition the n n array A into four n=2 n=2 subarrays as follows:
                          
               A11 A12
      AD                     :                                                          (27.11)
               A21 A22
      Observe now that we can ﬁll in subarray A11 recursively, since it does not depend
      on the entries of the other three subarrays. Once A11 is complete, we can continue
      to ﬁll in A12 and A21 recursively in parallel, because although they both depend
      on A11 , they do not depend on each other. Finally, we can ﬁll in A22 recursively.

      a. Give multithreaded pseudocode that performs this simple stencil calculation
         using a divide-and-conquer algorithm S IMPLE -S TENCIL based on the decom-
         position (27.11) and the discussion above. (Don’t worry about the details of the
         base case, which depends on the speciﬁc stencil.) Give and solve recurrences
         for the work and span of this algorithm in terms of n. What is the parallelism?

      b. Modify your solution to part (a) to divide an n n array into nine n=3 n=3
         subarrays, again recursing with as much parallelism as possible. Analyze this
         algorithm. How much more or less parallelism does this algorithm have com-
         pared with the algorithm from part (a)?

      c. Generalize your solutions to parts (a) and (b) as follows. Choose an integer
         b  2. Divide an n n array into b 2 subarrays, each of size n=b n=b, recursing
         with as much parallelism as possible. In terms of n and b, what are the work,
         span, and parallelism of your algorithm? Argue that, using this approach, the
         parallelism must be o.n/ for any choice of b  2. (Hint: For this last argument,
         show that the exponent of n in the parallelism is strictly less than 1 for any
         choice of b  2.)
