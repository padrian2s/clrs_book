374   Chapter 15 Dynamic Programming


      Step 2: A recursive solution
      Next, we deﬁne the cost of an optimal solution recursively in terms of the optimal
      solutions to subproblems. For the matrix-chain multiplication problem, we pick as
      our subproblems the problems of determining the minimum cost of parenthesizing
      Ai Ai C1    Aj for 1  i  j  n. Let mŒi; j  be the minimum number of scalar
      multiplications needed to compute the matrix Ai ::j ; for the full problem, the lowest-
      cost way to compute A1::n would thus be mŒ1; n.
         We can deﬁne mŒi; j  recursively as follows. If i D j , the problem is trivial;
      the chain consists of just one matrix Ai ::i D Ai , so that no scalar multiplications
      are necessary to compute the product. Thus, mŒi; i D 0 for i D 1; 2; : : : ; n. To
      compute mŒi; j  when i < j , we take advantage of the structure of an optimal
      solution from step 1. Let us assume that to optimally parenthesize, we split the
      product Ai Ai C1    Aj between Ak and AkC1 , where i  k < j . Then, mŒi; j 
      equals the minimum cost for computing the subproducts Ai ::k and AkC1::j , plus the
      cost of multiplying these two matrices together. Recalling that each matrix Ai is
      pi 1 pi , we see that computing the matrix product Ai ::k AkC1::j takes pi 1 pk pj
      scalar multiplications. Thus, we obtain
      mŒi; j  D mŒi; k C mŒk C 1; j  C pi 1 pk pj :
         This recursive equation assumes that we know the value of k, which we do not.
      There are only j i possible values for k, however, namely k D i; i C1; : : : ; j 1.
      Since the optimal parenthesization must use one of these values for k, we need only
      check them all to ﬁnd the best. Thus, our recursive deﬁnition for the minimum cost
      of parenthesizing the product Ai Ai C1    Aj becomes
                 (
                   0                                             if i D j ;
      mŒi; j  D                                                                     (15.7)
                    min fmŒi; k C mŒk C 1; j  C pi 1 pk pj g if i < j :
                   i k<j

         The mŒi; j  values give the costs of optimal solutions to subproblems, but they
      do not provide all the information we need to construct an optimal solution. To
      help us do so, we deﬁne sŒi; j  to be a value of k at which we split the product
      Ai Ai C1    Aj in an optimal parenthesization. That is, sŒi; j  equals a value k such
      that mŒi; j  D mŒi; k C mŒk C 1; j  C pi 1 pk pj .

      Step 3: Computing the optimal costs
      At this point, we could easily write a recursive algorithm based on recurrence (15.7)
      to compute the minimum cost mŒ1; n for multiplying A1 A2    An . As we saw for
      the rod-cutting problem, and as we shall see in Section 15.3, this recursive algo-
      rithm takes exponential time, which is no better than the brute-force method of
      checking each way of parenthesizing the product.
