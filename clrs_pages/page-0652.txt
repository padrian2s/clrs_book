           23.2 The algorithms of Kruskal and Prim                                           631




23.2 The algorithms of Kruskal and Prim

           The two minimum-spanning-tree algorithms described in this section elaborate on
           the generic method. They each use a speciﬁc rule to determine a safe edge in line 3
           of G ENERIC -MST. In Kruskal’s algorithm, the set A is a forest whose vertices are
           all those of the given graph. The safe edge added to A is always a least-weight
           edge in the graph that connects two distinct components. In Prim’s algorithm, the
           set A forms a single tree. The safe edge added to A is always a least-weight edge
           connecting the tree to a vertex not in the tree.

           Kruskal’s algorithm
           Kruskal’s algorithm ﬁnds a safe edge to add to the growing forest by ﬁnding, of all
           the edges that connect any two trees in the forest, an edge .u; / of least weight.
           Let C1 and C2 denote the two trees that are connected by .u; /. Since .u; / must
           be a light edge connecting C1 to some other tree, Corollary 23.2 implies that .u; /
           is a safe edge for C1 . Kruskal’s algorithm qualiﬁes as a greedy algorithm because
           at each step it adds to the forest an edge of least possible weight.
              Our implementation of Kruskal’s algorithm is like the algorithm to compute
           connected components from Section 21.1. It uses a disjoint-set data structure to
           maintain several disjoint sets of elements. Each set contains the vertices in one tree
           of the current forest. The operation F IND -S ET .u/ returns a representative element
           from the set that contains u. Thus, we can determine whether two vertices u and 
           belong to the same tree by testing whether F IND -S ET .u/ equals F IND -S ET ./. To
           combine trees, Kruskal’s algorithm calls the U NION procedure.

           MST-K RUSKAL .G; w/
           1 AD;
           2 for each vertex  2 G:V
           3      M AKE -S ET ./
           4 sort the edges of G:E into nondecreasing order by weight w
           5 for each edge .u; / 2 G:E, taken in nondecreasing order by weight
           6      if F IND -S ET .u/ ¤ F IND -S ET ./
           7            A D A [ f.u; /g
           8            U NION .u; /
           9 return A

              Figure 23.4 shows how Kruskal’s algorithm works. Lines 1–3 initialize the set A
           to the empty set and create jV j trees, one containing each vertex. The for loop in
           lines 5–8 examines edges in order of weight, from lowest to highest. The loop
