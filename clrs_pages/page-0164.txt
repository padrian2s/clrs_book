           Problems for Chapter 5                                                                143




Problems

           5-1 Probabilistic counting
           With a b-bit counter, we can ordinarily only count up to 2b  1. With R. Morris’s
           probabilistic counting, we can count up to a much larger value at the expense of
           some loss of precision.
              We let a counter value of i represent a count of ni for i D 0; 1; : : : ; 2b  1, where
           the ni form an increasing sequence of nonnegative values. We assume that the ini-
           tial value of the counter is 0, representing a count of n0 D 0. The I NCREMENT
           operation works on a counter containing the value i in a probabilistic manner. If
           i D 2b  1, then the operation reports an overﬂow error. Otherwise, the I NCRE -
           MENT operation increases the counter by 1 with probability 1=.ni C1  ni /, and it
           leaves the counter unchanged with probability 1  1=.ni C1  ni /.
              If we select ni D i for all i  0, then the counter is an ordinary one. More
           interesting situations arise if we select, say, ni D 2i 1 for i > 0 or ni D Fi (the
           ith Fibonacci number—see Section 3.2).
              For this problem, assume that n2b 1 is large enough that the probability of an
           overﬂow error is negligible.

           a. Show that the expected value represented by the counter after n I NCREMENT
              operations have been performed is exactly n.

           b. The analysis of the variance of the count represented by the counter depends
              on the sequence of the ni . Let us consider a simple case: ni D 100i for
              all i  0. Estimate the variance in the value represented by the register after n
              I NCREMENT operations have been performed.

           5-2 Searching an unsorted array
           This problem examines three algorithms for searching for a value x in an unsorted
           array A consisting of n elements.
              Consider the following randomized strategy: pick a random index i into A. If
           AŒi D x, then we terminate; otherwise, we continue the search by picking a new
           random index into A. We continue picking random indices into A until we ﬁnd an
           index j such that AŒj  D x or until we have checked every element of A. Note
           that we pick from the whole set of indices each time, so that we may examine a
           given element more than once.

           a. Write pseudocode for a procedure R ANDOM -S EARCH to implement the strat-
              egy above. Be sure that your algorithm terminates when all indices into A have
              been picked.
