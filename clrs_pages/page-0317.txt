296   Chapter 12 Binary Search Trees


         The procedure for deleting a given node ´ from a binary search tree T takes as
      arguments pointers to T and ´. It organizes its cases a bit differently from the three
      cases outlined previously by considering the four cases shown in Figure 12.4.
         If ´ has no left child (part (a) of the ﬁgure), then we replace ´ by its right child,
          which may or may not be NIL. When ´’s right child is NIL, this case deals with
          the situation in which ´ has no children. When ´’s right child is non-NIL, this
          case handles the situation in which ´ has just one child, which is its right child.
         If ´ has just one child, which is its left child (part (b) of the ﬁgure), then we
          replace ´ by its left child.
         Otherwise, ´ has both a left and a right child. We ﬁnd ´’s successor y, which
          lies in ´’s right subtree and has no left child (see Exercise 12.2-5). We want to
          splice y out of its current location and have it replace ´ in the tree.
             If y is ´’s right child (part (c)), then we replace ´ by y, leaving y’s right
              child alone.
             Otherwise, y lies within ´’s right subtree but is not ´’s right child (part (d)).
              In this case, we ﬁrst replace y by its own right child, and then we replace ´
              by y.
         In order to move subtrees around within the binary search tree, we deﬁne a
      subroutine T RANSPLANT, which replaces one subtree as a child of its parent with
      another subtree. When T RANSPLANT replaces the subtree rooted at node u with
      the subtree rooted at node , node u’s parent becomes node ’s parent, and u’s
      parent ends up having  as its appropriate child.

      T RANSPLANT .T; u; /
      1 if u:p == NIL
      2      T:root D 
      3 elseif u == u:p:left
      4      u:p:left D 
      5 else u:p:right D 
      6 if  ¤ NIL
      7      :p D u:p

      Lines 1–2 handle the case in which u is the root of T . Otherwise, u is either a left
      child or a right child of its parent. Lines 3–4 take care of updating u:p:left if u
      is a left child, and line 5 updates u:p:right if u is a right child. We allow  to be
      NIL, and lines 6–7 update :p if  is non-NIL. Note that T RANSPLANT does not
      attempt to update :left and :right; doing so, or not doing so, is the responsibility
      of T RANSPLANT’s caller.
