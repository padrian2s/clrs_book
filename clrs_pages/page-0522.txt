18.3 Deleting a key from a B-tree                                                                  501


(e) D deleted: case 3b


                             C L P T X


  A B        E J K           N O        Q R S           U V         Y Z



(e′) tree shrinks            C L P T X
     in height

  A B        E J K           N O        Q R S           U V         Y Z



(f) B deleted: case 3a     E L P T X


  A C         J K        N O        Q R S           U V         Y Z



Figure 18.8, continued (e) Deletion of D. This is case 3b: the recursion cannot descend to
node CL because it has only 2 keys, so we push P down and merge it with CL and TX to form
CLP TX; then we delete D from a leaf (case 1). (e0 ) After (e), we delete the root and the tree shrinks
in height by one. (f) Deletion of B. This is case 3a: C moves to ﬁll B’s position and E moves to
ﬁll C ’s position.


    a. If the child y that precedes k in node x has at least t keys, then ﬁnd the
       predecessor k 0 of k in the subtree rooted at y. Recursively delete k 0 , and
       replace k by k 0 in x. (We can ﬁnd k 0 and delete it in a single downward
       pass.)
    b. If y has fewer than t keys, then, symmetrically, examine the child ´ that
       follows k in node x. If ´ has at least t keys, then ﬁnd the successor k 0 of k in
       the subtree rooted at ´. Recursively delete k 0 , and replace k by k 0 in x. (We
       can ﬁnd k 0 and delete it in a single downward pass.)
    c. Otherwise, if both y and ´ have only t  1 keys, merge k and all of ´ into y,
       so that x loses both k and the pointer to ´, and y now contains 2t  1 keys.
       Then free ´ and recursively delete k from y.
3. If the key k is not present in internal node x, determine the root x:ci of the
   appropriate subtree that must contain k, if k is in the tree at all. If x:ci has
   only t  1 keys, execute step 3a or 3b as necessary to guarantee that we descend
   to a node containing at least t keys. Then ﬁnish by recursing on the appropriate
   child of x.
