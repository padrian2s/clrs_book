32.4 The Knuth-Morris-Pratt algorithm                                                1009


   We now ﬁnish the proof that C OMPUTE -P REFIX -F UNCTION computes  cor-
rectly. In the procedure C OMPUTE -P REFIX -F UNCTION, at the start of each iter-
ation of the for loop of lines 5–10, we have that k D Œq  1. This condition
is enforced by lines 3 and 4 when the loop is ﬁrst entered, and it remains true in
each successive iteration because of line 10. Lines 6–9 adjust k so that it becomes
the correct value of Œq. The while loop of lines 6–7 searches through all values
k 2   Œq  1 until it ﬁnds a value of k for which P Œk C 1 D P Œq; at that point,
k is the largest value in the set Eq1 , so that, by Corollary 32.7, we can set Œq
to k C 1. If the while loop cannot ﬁnd a k 2   Œq  1 such that P Œk C 1 D P Œq,
then k equals 0 at line 8. If P Œ1 D P Œq, then we should set both k and Œq to 1;
otherwise we should leave k alone and set Œq to 0. Lines 8–10 set k and Œq
correctly in either case. This completes our proof of the correctness of C OMPUTE -
P REFIX -F UNCTION.

Correctness of the Knuth-Morris-Pratt algorithm
We can think of the procedure KMP-M ATCHER as a reimplemented version of
the procedure F INITE -AUTOMATON -M ATCHER, but using the preﬁx function 
to compute state transitions. Speciﬁcally, we shall prove that in the ith iteration of
the for loops of both KMP-M ATCHER and F INITE -AUTOMATON -M ATCHER, the
state q has the same value when we test for equality with m (at line 10 in KMP-
M ATCHER and at line 5 in F INITE -AUTOMATON -M ATCHER). Once we have
argued that KMP-M ATCHER simulates the behavior of F INITE -AUTOMATON -
M ATCHER, the correctness of KMP-M ATCHER follows from the correctness of
F INITE -AUTOMATON -M ATCHER (though we shall see a little later why line 12 in
KMP-M ATCHER is necessary).
   Before we formally prove that KMP-M ATCHER correctly simulates F INITE -
AUTOMATON -M ATCHER, let’s take a moment to understand how the preﬁx func-
tion  replaces the ı transition function. Recall that when a string-matching
automaton is in state q and it scans a character a D T Œi, it moves to a new
state ı.q; a/. If a D P Œq C 1, so that a continues to match the pattern, then
ı.q; a/ D q C 1. Otherwise, a ¤ P Œq C 1, so that a does not continue to match
the pattern, and 0  ı.q; a/  q. In the ﬁrst case, when a continues to match,
KMP-M ATCHER moves to state q C 1 without referring to the  function: the
while loop test in line 6 comes up false the ﬁrst time, the test in line 8 comes up
true, and line 9 increments q.
   The  function comes into play when the character a does not continue to match
the pattern, so that the new state ı.q; a/ is either q or to the left of q along the spine
of the automaton. The while loop of lines 6–7 in KMP-M ATCHER iterates through
the states in   Œq, stopping either when it arrives in a state, say q 0 , such that a
matches P Œq 0 C 1 or q 0 has gone all the way down to 0. If a matches P Œq 0 C 1,
