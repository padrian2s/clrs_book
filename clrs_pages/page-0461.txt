440   Chapter 16 Greedy Algorithms


      with jV j  1 edges, and since
                   X
      w 0 .A/ D        w 0 .e/
                   e2A
                X
              D  .w0  w.e//
                   e2A
                                     X
              D .jV j  1/w0              w.e/
                                     e2A
              D .jV j  1/w0  w.A/
      for any maximal independent subset A, an independent subset that maximizes the
      quantity w 0 .A/ must minimize w.A/. Thus, any algorithm that can ﬁnd an optimal
      subset A in an arbitrary matroid can solve the minimum-spanning-tree problem.
         Chapter 23 gives algorithms for the minimum-spanning-tree problem, but here
      we give a greedy algorithm that works for any weighted matroid. The algorithm
      takes as input a weighted matroid M D .S;  / with an associated positive weight
      function w, and it returns an optimal subset A. In our pseudocode, we denote the
      components of M by M:S and M: and the weight function by w. The algorithm
      is greedy because it considers in turn each element x 2 S, in order of monotoni-
      cally decreasing weight, and immediately adds it to the set A being accumulated if
      A [ fxg is independent.

      G REEDY .M; w/
      1 AD;
      2 sort M:S into monotonically decreasing order by weight w
      3 for each x 2 M:S, taken in monotonically decreasing order by weight w.x/
      4      if A [ fxg 2 M:
      5           A D A [ fxg
      6 return A
      Line 4 checks whether adding each element x to A would maintain A as an inde-
      pendent set. If A would remain independent, then line 5 adds x to A. Otherwise, x
      is discarded. Since the empty set is independent, and since each iteration of the for
      loop maintains A’s independence, the subset A is always independent, by induc-
      tion. Therefore, G REEDY always returns an independent subset A. We shall see in
      a moment that A is a subset of maximum possible weight, so that A is an optimal
      subset.
         The running time of G REEDY is easy to analyze. Let n denote jSj. The sorting
      phase of G REEDY takes time O.n lg n/. Line 4 executes exactly n times, once for
      each element of S. Each execution of line 4 requires a check on whether or not
      the set A [ fxg is independent. If each such check takes time O.f .n//, the entire
      algorithm runs in time O.n lg n C nf .n//.
