334   Chapter 13 Red-Black Trees


                            G: 4


                  B: 7              H: 5


          A: 10          E: 23             K: 65


                                        I: 73



      Figure 13.9 A treap. Each node x is labeled with x: key : x: priority. For example, the root has
      key G and priority 4.


         We will examine a data structure that answers this question in the afﬁrmative. A
      treap is a binary search tree with a modiﬁed way of ordering the nodes. Figure 13.9
      shows an example. As usual, each node x in the tree has a key value x:key. In
      addition, we assign x:priority, which is a random number chosen independently
      for each node. We assume that all priorities are distinct and also that all keys are
      distinct. The nodes of the treap are ordered so that the keys obey the binary-search-
      tree property and the priorities obey the min-heap order property:
           If  is a left child of u, then :key < u:key.
           If  is a right child of u, then :key > u:key.
           If  is a child of u, then :priority > u:priority.
      (This combination of properties is why the tree is called a “treap”: it has features
      of both a binary search tree and a heap.)
         It helps to think of treaps in the following way. Suppose that we insert nodes
      x1 ; x2 ; : : : ; xn , with associated keys, into a treap. Then the resulting treap is the
      tree that would have been formed if the nodes had been inserted into a normal
      binary search tree in the order given by their (randomly chosen) priorities, i.e.,
      xi :priority < xj :priority means that we had inserted xi before xj .

      a. Show that given a set of nodes x1 ; x2 ; : : : ; xn , with associated keys and priori-
         ties, all distinct, the treap associated with these nodes is unique.

      b. Show that the expected height of a treap is ‚.lg n/, and hence the expected time
         to search for a value in the treap is ‚.lg n/.

      Let us see how to insert a new node into an existing treap. The ﬁrst thing we do
      is assign to the new node a random priority. Then we call the insertion algorithm,
      which we call T REAP -I NSERT, whose operation is illustrated in Figure 13.10.
