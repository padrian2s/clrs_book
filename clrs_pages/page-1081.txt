1060   Chapter 34 NP-Completeness


       polynomial-time algorithm A. We shall use a classic “simulation” argument to
       construct another polynomial-time algorithm A0 that decides L. Because A ac-
       cepts L in time O.nk / for some constant k, there also exists a constant c such
       that A accepts L in at most cnk steps. For any input string x, the algorithm A0
       simulates cnk steps of A. After simulating cnk steps, algorithm A0 inspects the be-
       havior of A. If A has accepted x, then A0 accepts x by outputting a 1. If A has not
       accepted x, then A0 rejects x by outputting a 0. The overhead of A0 simulating A
       does not increase the running time by more than a polynomial factor, and thus A0
       is a polynomial-time algorithm that decides L.

          Note that the proof of Theorem 34.2 is nonconstructive. For a given language
       L 2 P, we may not actually know a bound on the running time for the algorithm A
       that accepts L. Nevertheless, we know that such a bound exists, and therefore, that
       an algorithm A0 exists that can check the bound, even though we may not be able
       to ﬁnd the algorithm A0 easily.

       Exercises

       34.1-1
       Deﬁne the optimization problem LONGEST-PATH-LENGTH as the relation that
       associates each instance of an undirected graph and two vertices with the num-
       ber of edges in a longest simple path between the two vertices. Deﬁne the de-
       cision problem LONGEST-PATH D fhG; u; ; ki W G D .V; E/ is an undi-
       rected graph, u;  2 V , k  0 is an integer, and there exists a simple path
       from u to  in G consisting of at least k edgesg. Show that the optimization prob-
       lem LONGEST-PATH-LENGTH can be solved in polynomial time if and only if
       LONGEST-PATH 2 P.

       34.1-2
       Give a formal deﬁnition for the problem of ﬁnding the longest simple cycle in an
       undirected graph. Give a related decision problem. Give the language correspond-
       ing to the decision problem.

       34.1-3
       Give a formal encoding of directed graphs as binary strings using an adjacency-
       matrix representation. Do the same using an adjacency-list representation. Argue
       that the two representations are polynomially related.

       34.1-4
       Is the dynamic-programming algorithm for the 0-1 knapsack problem that is asked
       for in Exercise 16.2-2 a polynomial-time algorithm? Explain your answer.
