234   Chapter 10 Elementary Data Structures


                1    2   3   4   5    6    7   8   9   10 11 12
      (a)   Q                              15 6    9   8    4


                                     Q:head D 7            Q:tail D 12

                1    2   3   4   5    6    7   8   9   10 11 12
      (b)   Q 3      5                     15 6    9   8    4 17


                    Q:tail D 3       Q:head D 7

                1    2   3   4   5    6    7   8   9   10 11 12
      (c)   Q 3      5                     15 6    9   8    4 17


                    Q:tail D 3            Q:head D 8


      Figure 10.2 A queue implemented using an array QŒ1 : : 12. Queue elements appear only in the
      lightly shaded positions. (a) The queue has 5 elements, in locations QŒ7 : : 11. (b) The conﬁguration
      of the queue after the calls E NQUEUE.Q; 17/, E NQUEUE.Q; 3/, and E NQUEUE.Q; 5/. (c) The
      conﬁguration of the queue after the call D EQUEUE.Q/ returns the key value 15 formerly at the
      head of the queue. The new head has key 6.


      Queues
      We call the I NSERT operation on a queue E NQUEUE, and we call the D ELETE
      operation D EQUEUE; like the stack operation P OP, D EQUEUE takes no element ar-
      gument. The FIFO property of a queue causes it to operate like a line of customers
      waiting to pay a cashier. The queue has a head and a tail. When an element is en-
      queued, it takes its place at the tail of the queue, just as a newly arriving customer
      takes a place at the end of the line. The element dequeued is always the one at
      the head of the queue, like the customer at the head of the line who has waited the
      longest.
         Figure 10.2 shows one way to implement a queue of at most n  1 elements
      using an array QŒ1 : : n. The queue has an attribute Q:head that indexes, or points
      to, its head. The attribute Q:tail indexes the next location at which a newly arriv-
      ing element will be inserted into the queue. The elements in the queue reside in
      locations Q:head; Q:head C 1; : : : ; Q:tail  1, where we “wrap around” in the
      sense that location 1 immediately follows location n in a circular order. When
      Q:head D Q:tail, the queue is empty. Initially, we have Q:head D Q:tail D 1.
      If we attempt to dequeue an element from an empty queue, the queue underﬂows.
