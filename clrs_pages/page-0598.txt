21.4 Analysis of union by rank with path compression                              577


A˛.n/ .x:rank/  A˛.n/ .1/ (because Ak .j / is strictly increasing)
                n         (by the deﬁnition of ˛.n/)
               > x:p:rank (by Lemma 21.6) ,
which implies that level.x/ < ˛.n/. Note that because x:p:rank monotonically
increases over time, so does level.x/.
   The second auxiliary function applies when x:rank  1:
               ˚
iter.x/ D max i W x:p:rank  A.ilevel.x/
                                   /
                                         .x:rank/ :
That is, iter.x/ is the largest number of times we can iteratively apply Alevel.x/ ,
applied initially to x’s rank, before we get a value greater than x’s parent’s rank.
  We claim that when x:rank  1, we have
1  iter.x/  x:rank ;                                                         (21.2)
which we see as follows. We have
x:p:rank  Alevel.x/ .x:rank/ (by deﬁnition of level.x/)
             D A.1/
                level.x/ .x:rank/ (by deﬁnition of functional iteration) ,

which implies that iter.x/  1, and we have

A.x: rankC1/
 level.x/    .x:rank/ D Alevel.x/C1 .x:rank/ (by deﬁnition of Ak .j /)
                      > x:p:rank             (by deﬁnition of level.x/) ,
which implies that iter.x/  x:rank. Note that because x:p:rank monotonically
increases over time, in order for iter.x/ to decrease, level.x/ must increase. As long
as level.x/ remains unchanged, iter.x/ must either increase or remain unchanged.
   With these auxiliary functions in place, we are ready to deﬁne the potential of
node x after q operations:
          (
            ˛.n/  x:rank                          if x is a root or x:rank D 0 ;
q .x/ D
            .˛.n/  level.x//x:rank  iter.x/ if x is not a root and x:rank  1 :

We next investigate some useful properties of node potentials.

Lemma 21.8
For every node x, and for all operation counts q, we have
0  q .x/  ˛.n/  x:rank :
