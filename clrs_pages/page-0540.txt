19.3 Decreasing a key and deleting a node                                       519


mum degree D.n/ is O.lg n/, which will imply that F IB -H EAP -E XTRACT-M IN
and F IB -H EAP -D ELETE run in O.lg n/ amortized time.

Decreasing a key
In the following pseudocode for the operation F IB -H EAP -D ECREASE -K EY, we
assume as before that removing a node from a linked list does not change any of
the structural attributes in the removed node.
F IB -H EAP -D ECREASE -K EY .H; x; k/
1 if k > x:key
2        error “new key is greater than current key”
3 x:key D k
4 y D x:p
5 if y ¤ NIL and x:key < y:key
6        C UT.H; x; y/
7        C ASCADING -C UT .H; y/
8 if x:key < H:min:key
9        H:min D x
C UT.H; x; y/
1 remove x from the child list of y, decrementing y:degree
2 add x to the root list of H
3 x:p D NIL
4 x:mark D FALSE
C ASCADING -C UT .H; y/
1 ´ D y:p
2 if ´ ¤ NIL
3      if y:mark == FALSE
4           y:mark D TRUE
5      else C UT.H; y; ´/
6           C ASCADING -C UT .H; ´/
The F IB -H EAP -D ECREASE -K EY procedure works as follows. Lines 1–3 ensure
that the new key is no greater than the current key of x and then assign the new key
to x. If x is a root or if x:key  y:key, where y is x’s parent, then no structural
changes need occur, since min-heap order has not been violated. Lines 4–5 test for
this condition.
   If min-heap order has been violated, many changes may occur. We start by
cutting x in line 6. The C UT procedure “cuts” the link between x and its parent y,
making x a root.
