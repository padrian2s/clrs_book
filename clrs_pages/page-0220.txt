8.3 Radix sort                                                                   199


Lemma 8.4
Given n b-bit numbers and any positive integer r  b, R ADIX -S ORT correctly sorts
these numbers in ‚..b=r/.n C 2r // time if the stable sort it uses takes ‚.n C k/
time for inputs in the range 0 to k.

Proof For a value r  b, we view each key as having d D db=re digits of r bits
each. Each digit is an integer in the range 0 to 2r  1, so that we can use counting
sort with k D 2r  1. (For example, we can view a 32-bit word as having four 8-bit
digits, so that b D 32, r D 8, k D 2r  1 D 255, and d D b=r D 4.) Each pass of
counting sort takes time ‚.n C k/ D ‚.n C 2r / and there are d passes, for a total
running time of ‚.d.n C 2r // D ‚..b=r/.n C 2r //.

   For given values of n and b, we wish to choose the value of r, with r  b,
that minimizes the expression .b=r/.n C 2r /. If b < blg nc, then for any value
of r  b, we have that .n C 2r / D ‚.n/. Thus, choosing r D b yields a running
time of .b=b/.n C 2b / D ‚.n/, which is asymptotically optimal. If b  blg nc,
then choosing r D blg nc gives the best time to within a constant factor, which
we can see as follows. Choosing r D blg nc yields a running time of ‚.bn= lg n/.
As we increase r above blg nc, the 2r term in the numerator increases faster than
the r term in the denominator, and so increasing r above blg nc yields a running
time of .bn= lg n/. If instead we were to decrease r below blg nc, then the b=r
term increases and the n C 2r term remains at ‚.n/.
   Is radix sort preferable to a comparison-based sorting algorithm, such as quick-
sort? If b D O.lg n/, as is often the case, and we choose r  lg n, then radix sort’s
running time is ‚.n/, which appears to be better than quicksort’s expected running
time of ‚.n lg n/. The constant factors hidden in the ‚-notation differ, however.
Although radix sort may make fewer passes than quicksort over the n keys, each
pass of radix sort may take signiﬁcantly longer. Which sorting algorithm we prefer
depends on the characteristics of the implementations, of the underlying machine
(e.g., quicksort often uses hardware caches more effectively than radix sort), and
of the input data. Moreover, the version of radix sort that uses counting sort as the
intermediate stable sort does not sort in place, which many of the ‚.n lg n/-time
comparison sorts do. Thus, when primary memory storage is at a premium, we
might prefer an in-place algorithm such as quicksort.

Exercises

8.3-1
Using Figure 8.3 as a model, illustrate the operation of R ADIX -S ORT on the fol-
lowing list of English words: COW, DOG, SEA, RUG, ROW, MOB, BOX, TAB,
BAR, EAR, TAR, DIG, BIG, TEA, NOW, FOX.
