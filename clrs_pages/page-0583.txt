562   Chapter 21 Data Structures for Disjoint Sets


      M AKE -S ET .x/ creates a new set whose only member (and thus representative)
        is x. Since the sets are disjoint, we require that x not already be in some other
        set.
      U NION .x; y/ unites the dynamic sets that contain x and y, say Sx and Sy , into a
        new set that is the union of these two sets. We assume that the two sets are dis-
        joint prior to the operation. The representative of the resulting set is any member
        of Sx [ Sy , although many implementations of U NION speciﬁcally choose the
        representative of either Sx or Sy as the new representative. Since we require
        the sets in the collection to be disjoint, conceptually we destroy sets Sx and Sy ,
        removing them from the collection S . In practice, we often absorb the elements
        of one of the sets into the other set.
      F IND -S ET .x/ returns a pointer to the representative of the (unique) set contain-
         ing x.
         Throughout this chapter, we shall analyze the running times of disjoint-set data
      structures in terms of two parameters: n, the number of M AKE -S ET operations,
      and m, the total number of M AKE -S ET, U NION, and F IND -S ET operations. Since
      the sets are disjoint, each U NION operation reduces the number of sets by one.
      After n  1 U NION operations, therefore, only one set remains. The number of
      U NION operations is thus at most n  1. Note also that since the M AKE -S ET
      operations are included in the total number of operations m, we have m  n. We
      assume that the n M AKE -S ET operations are the ﬁrst n operations performed.

      An application of disjoint-set data structures
      One of the many applications of disjoint-set data structures arises in determin-
      ing the connected components of an undirected graph (see Section B.4). Fig-
      ure 21.1(a), for example, shows a graph with four connected components.
         The procedure C ONNECTED -C OMPONENTS that follows uses the disjoint-set
      operations to compute the connected components of a graph. Once C ONNECTED -
      C OMPONENTS has preprocessed the graph, the procedure S AME -C OMPONENT
      answers queries about whether two vertices are in the same connected component.1
      (In pseudocode, we denote the set of vertices of a graph G by G:V and the set of
      edges by G:E.)


      1 When the edges of the graph are static—not changing over time—we can compute the connected

      components faster by using depth-ﬁrst search (Exercise 22.3-12). Sometimes, however, the edges
      are added dynamically and we need to maintain the connected components as each edge is added. In
      this case, the implementation given here can be more efﬁcient than running a new depth-ﬁrst search
      for each new edge.
