332   Chapter 13 Red-Black Trees


      a. For a general persistent binary search tree, identify the nodes that we need to
         change to insert a key k or delete a node y.

      b. Write a procedure P ERSISTENT-T REE -I NSERT that, given a persistent tree T
         and a key k to insert, returns a new persistent tree T 0 that is the result of insert-
         ing k into T .

      c. If the height of the persistent binary search tree T is h, what are the time and
         space requirements of your implementation of P ERSISTENT-T REE -I NSERT?
         (The space requirement is proportional to the number of new nodes allocated.)

      d. Suppose that we had included the parent attribute in each node. In this case,
         P ERSISTENT-T REE -I NSERT would need to perform additional copying. Prove
         that P ERSISTENT-T REE -I NSERT would then require .n/ time and space,
         where n is the number of nodes in the tree.

      e. Show how to use red-black trees to guarantee that the worst-case running time
         and space are O.lg n/ per insertion or deletion.

      13-2 Join operation on red-black trees
      The join operation takes two dynamic sets S1 and S2 and an element x such that
      for any x1 2 S1 and x2 2 S2 , we have x1 :key  x:key  x2 :key. It returns a set
      S D S1 [ fxg [ S2 . In this problem, we investigate how to implement the join
      operation on red-black trees.
      a. Given a red-black tree T , let us store its black-height as the new attribute T:bh.
         Argue that RB-I NSERT and RB-D ELETE can maintain the bh attribute with-
         out requiring extra storage in the nodes of the tree and without increasing the
         asymptotic running times. Show that while descending through T , we can de-
         termine the black-height of each node we visit in O.1/ time per node visited.
      We wish to implement the operation RB-J OIN .T1 ; x; T2 /, which destroys T1 and T2
      and returns a red-black tree T D T1 [ fxg [ T2 . Let n be the total number of nodes
      in T1 and T2 .
      b. Assume that T1 :bh  T2 :bh. Describe an O.lg n/-time algorithm that Ô¨Ånds a
         black node y in T1 with the largest key from among those nodes whose black-
         height is T2 :bh.

      c. Let Ty be the subtree rooted at y. Describe how Ty [ fxg [ T2 can replace Ty
         in O.1/ time without destroying the binary-search-tree property.

      d. What color should we make x so that red-black properties 1, 3, and 5 are main-
         tained? Describe how to enforce properties 2 and 4 in O.lg n/ time.
