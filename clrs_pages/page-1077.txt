1056   Chapter 34 NP-Completeness


       like the deﬁnition to be independent of any particular encoding. That is, the ef-
       ﬁciency of solving a problem should not depend on how the problem is encoded.
       Unfortunately, it depends quite heavily on the encoding. For example, suppose that
       an integer k is to be provided as the sole input to an algorithm, and suppose that
       the running time of the algorithm is ‚.k/. If the integer k is provided in unary—a
       string of k 1s—then the running time of the algorithm is O.n/ on length-n inputs,
       which is polynomial time. If we use the more natural binary representation of the
       integer k, however, then the input length is n D blg kc C 1. In this case, the run-
       ning time of the algorithm is ‚.k/ D ‚.2n /, which is exponential in the size of the
       input. Thus, depending on the encoding, the algorithm runs in either polynomial
       or superpolynomial time.
          How we encode an abstract problem matters quite a bit to how we understand
       polynomial time. We cannot really talk about solving an abstract problem without
       ﬁrst specifying an encoding. Nevertheless, in practice, if we rule out “expensive”
       encodings such as unary ones, the actual encoding of a problem makes little dif-
       ference to whether the problem can be solved in polynomial time. For example,
       representing integers in base 3 instead of binary has no effect on whether a prob-
       lem is solvable in polynomial time, since we can convert an integer represented in
       base 3 to an integer represented in base 2 in polynomial time.
          We say that a function f W f0; 1g ! f0; 1g is polynomial-time computable
       if there exists a polynomial-time algorithm A that, given any input x 2 f0; 1g ,
       produces as output f .x/. For some set I of problem instances, we say that two en-
       codings e1 and e2 are polynomially related if there exist two polynomial-time com-
       putable functions f12 and f21 such that for any i 2 I , we have f12 .e1 .i// D e2 .i/
       and f21 .e2 .i// D e1 .i/.5 That is, a polynomial-time algorithm can compute the en-
       coding e2 .i/ from the encoding e1 .i/, and vice versa. If two encodings e1 and e2 of
       an abstract problem are polynomially related, whether the problem is polynomial-
       time solvable or not is independent of which encoding we use, as the following
       lemma shows.

       Lemma 34.1
       Let Q be an abstract decision problem on an instance set I , and let e1 and e2 be
       polynomially related encodings on I . Then, e1 .Q/ 2 P if and only if e2 .Q/ 2 P.

       5 Technically, we also require the functions f
                                                           12 and f21 to “map noninstances to noninstances.”
       A noninstance of an encoding e is a string x 2 f0; 1g such that there is no instance i for which
       e.i/ D x. We require that f12 .x/ D y for every noninstance x of encoding e1 , where y is some non-
       instance of e2 , and that f21 .x 0 / D y 0 for every noninstance x 0 of e2 , where y 0 is some noninstance
       of e1 .
