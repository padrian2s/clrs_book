520   Chapter 19 Fibonacci Heaps


         We use the mark attributes to obtain the desired time bounds. They record a little
      piece of the history of each node. Suppose that the following events have happened
      to node x:
      1. at some time, x was a root,
      2. then x was linked to (made the child of) another node,
      3. then two children of x were removed by cuts.
      As soon as the second child has been lost, we cut x from its parent, making it a new
      root. The attribute x:mark is TRUE if steps 1 and 2 have occurred and one child
      of x has been cut. The C UT procedure, therefore, clears x:mark in line 4, since it
      performs step 1. (We can now see why line 3 of F IB -H EAP -L INK clears y:mark:
      node y is being linked to another node, and so step 2 is being performed. The next
      time a child of y is cut, y:mark will be set to TRUE.)
         We are not yet done, because x might be the second child cut from its parent y
      since the time that y was linked to another node. Therefore, line 7 of F IB -H EAP -
      D ECREASE -K EY attempts to perform a cascading-cut operation on y. If y is a
      root, then the test in line 2 of C ASCADING -C UT causes the procedure to just return.
      If y is unmarked, the procedure marks it in line 4, since its ﬁrst child has just been
      cut, and returns. If y is marked, however, it has just lost its second child; y is cut
      in line 5, and C ASCADING -C UT calls itself recursively in line 6 on y’s parent ´.
      The C ASCADING -C UT procedure recurses its way up the tree until it ﬁnds either a
      root or an unmarked node.
         Once all the cascading cuts have occurred, lines 8–9 of F IB -H EAP -D ECREASE -
      K EY ﬁnish up by updating H:min if necessary. The only node whose key changed
      was the node x whose key decreased. Thus, the new minimum node is either the
      original minimum node or node x.
         Figure 19.5 shows the execution of two calls of F IB -H EAP -D ECREASE -K EY,
      starting with the Fibonacci heap shown in Figure 19.5(a). The ﬁrst call, shown
      in Figure 19.5(b), involves no cascading cuts. The second call, shown in Fig-
      ures 19.5(c)–(e), invokes two cascading cuts.
         We shall now show that the amortized cost of F IB -H EAP -D ECREASE -K EY is
      only O.1/. We start by determining its actual cost. The F IB -H EAP -D ECREASE -
      K EY procedure takes O.1/ time, plus the time to perform the cascading cuts. Sup-
      pose that a given invocation of F IB -H EAP -D ECREASE -K EY results in c calls of
      C ASCADING -C UT (the call made from line 7 of F IB -H EAP -D ECREASE -K EY fol-
      lowed by c  1 recursive calls of C ASCADING -C UT). Each call of C ASCADING -
      C UT takes O.1/ time exclusive of recursive calls. Thus, the actual cost of F IB -
      H EAP -D ECREASE -K EY, including all recursive calls, is O.c/.
         We next compute the change in potential. Let H denote the Fibonacci heap just
      prior to the F IB -H EAP -D ECREASE -K EY operation. The call to C UT in line 6 of
