492   Chapter 18 B-Trees


      B-T REE -S EARCH .x; k/
      1 i D1
      2 while i  x:n and k > x:keyi
      3      i D i C1
      4 if i  x:n and k == x:keyi
      5      return .x; i/
      6 elseif x:leaf
      7      return NIL
      8 else D ISK -R EAD .x:ci /
      9      return B-T REE -S EARCH .x:ci ; k/
      Using a linear-search procedure, lines 1–3 ﬁnd the smallest index i such that
      k  x:keyi , or else they set i to x:n C 1. Lines 4–5 check to see whether we
      have now discovered the key, returning if we have. Otherwise, lines 6–9 either ter-
      minate the search unsuccessfully (if x is a leaf) or recurse to search the appropriate
      subtree of x, after performing the necessary D ISK -R EAD on that child.
         Figure 18.1 illustrates the operation of B-T REE -S EARCH. The procedure exam-
      ines the lightly shaded nodes during a search for the key R.
         As in the T REE -S EARCH procedure for binary search trees, the nodes encoun-
      tered during the recursion form a simple path downward from the root of the
      tree. The B-T REE -S EARCH procedure therefore accesses O.h/ D O.log t n/ disk
      pages, where h is the height of the B-tree and n is the number of keys in the B-tree.
      Since x:n < 2t, the while loop of lines 2–3 takes O.t/ time within each node, and
      the total CPU time is O.th/ D O.t log t n/.

      Creating an empty B-tree
      To build a B-tree T , we ﬁrst use B-T REE -C REATE to create an empty root node
      and then call B-T REE -I NSERT to add new keys. Both of these procedures use an
      auxiliary procedure A LLOCATE -N ODE, which allocates one disk page to be used
      as a new node in O.1/ time. We can assume that a node created by A LLOCATE -
      N ODE requires no D ISK -R EAD, since there is as yet no useful information stored
      on the disk for that node.
      B-T REE -C REATE .T /
      1 x D A LLOCATE -N ODE ./
      2 x:leaf D TRUE
      3 x:n D 0
      4 D ISK -W RITE .x/
      5 T:root D x
      B-T REE -C REATE requires O.1/ disk operations and O.1/ CPU time.
