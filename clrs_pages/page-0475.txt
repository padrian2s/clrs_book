454   Chapter 17 Amortized Analysis


      analysis, we assign the amortized cost of each operation to be the average cost. In
      this example, therefore, all three stack operations have an amortized cost of O.1/.
         We emphasize again that although we have just shown that the average cost, and
      hence the running time, of a stack operation is O.1/, we did not use probabilistic
      reasoning. We actually showed a worst-case bound of O.n/ on a sequence of n
      operations. Dividing this total cost by n yielded the average cost per operation, or
      the amortized cost.

      Incrementing a binary counter
      As another example of aggregate analysis, consider the problem of implementing
      a k-bit binary counter that counts upward from 0. We use an array AŒ0 : : k  1 of
      bits, where A:length D k, as the counter. A binary number x that is stored in the
      counter has its lowest-order bit in AŒ0 and its highest-order bit in AŒk  1, so that
            Pk1
      x D i D0 AŒi  2i . Initially, x D 0, and thus AŒi D 0 for i D 0; 1; : : : ; k  1. To
      add 1 (modulo 2k ) to the value in the counter, we use the following procedure.

      I NCREMENT .A/
      1 i D0
      2 while i < A:length and AŒi == 1
      3      AŒi D 0
      4      i D i C1
      5 if i < A:length
      6      AŒi D 1

      Figure 17.2 shows what happens to a binary counter as we increment it 16 times,
      starting with the initial value 0 and ending with the value 16. At the start of
      each iteration of the while loop in lines 2–4, we wish to add a 1 into position i.
      If AŒi D 1, then adding 1 ﬂips the bit to 0 in position i and yields a carry of 1,
      to be added into position i C 1 on the next iteration of the loop. Otherwise, the
      loop ends, and then, if i < k, we know that AŒi D 0, so that line 6 adds a 1 into
      position i, ﬂipping the 0 to a 1. The cost of each I NCREMENT operation is linear
      in the number of bits ﬂipped.
         As with the stack example, a cursory analysis yields a bound that is correct but
      not tight. A single execution of I NCREMENT takes time ‚.k/ in the worst case, in
      which array A contains all 1s. Thus, a sequence of n I NCREMENT operations on
      an initially zero counter takes time O.nk/ in the worst case.
         We can tighten our analysis to yield a worst-case cost of O.n/ for a sequence of n
      I NCREMENT operations by observing that not all bits ﬂip each time I NCREMENT
      is called. As Figure 17.2 shows, AŒ0 does ﬂip each time I NCREMENT is called.
      The next bit up, AŒ1, ﬂips only every other time: a sequence of n I NCREMENT
