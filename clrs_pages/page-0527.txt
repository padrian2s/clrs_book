506   Chapter 19 Fibonacci Heaps



                         Binary heap    Fibonacci heap
      Procedure          (worst-case)     (amortized)
      M AKE -H EAP          ‚.1/            ‚.1/
      I NSERT              ‚.lg n/          ‚.1/
      M INIMUM              ‚.1/            ‚.1/
      E XTRACT-M IN        ‚.lg n/         O.lg n/
      U NION                ‚.n/            ‚.1/
      D ECREASE -K EY      ‚.lg n/          ‚.1/
      D ELETE              ‚.lg n/         O.lg n/


      Figure 19.1 Running times for operations on two implementations of mergeable heaps. The num-
      ber of items in the heap(s) at the time of an operation is denoted by n.


         As the table in Figure 19.1 shows, if we don’t need the U NION operation, ordi-
      nary binary heaps, as used in heapsort (Chapter 6), work fairly well. Operations
      other than U NION run in worst-case time O.lg n/ on a binary heap. If we need
      to support the U NION operation, however, binary heaps perform poorly. By con-
      catenating the two arrays that hold the binary heaps to be merged and then running
      B UILD -M IN -H EAP (see Section 6.3), the U NION operation takes ‚.n/ time in the
      worst case.
         Fibonacci heaps, on the other hand, have better asymptotic time bounds than
      binary heaps for the I NSERT, U NION, and D ECREASE -K EY operations, and they
      have the same asymptotic running times for the remaining operations. Note, how-
      ever, that the running times for Fibonacci heaps in Figure 19.1 are amortized time
      bounds, not worst-case per-operation time bounds. The U NION operation takes
      only constant amortized time in a Fibonacci heap, which is signiﬁcantly better
      than the linear worst-case time required in a binary heap (assuming, of course, that
      an amortized time bound sufﬁces).

      Fibonacci heaps in theory and practice
      From a theoretical standpoint, Fibonacci heaps are especially desirable when the
      number of E XTRACT-M IN and D ELETE operations is small relative to the number
      of other operations performed. This situation arises in many applications. For
      example, some algorithms for graph problems may call D ECREASE -K EY once per
      edge. For dense graphs, which have many edges, the ‚.1/ amortized time of each
      call of D ECREASE -K EY adds up to a big improvement over the ‚.lg n/ worst-case
      time of binary heaps. Fast algorithms for problems such as computing minimum
      spanning trees (Chapter 23) and ﬁnding single-source shortest paths (Chapter 24)
      make essential use of Fibonacci heaps.
