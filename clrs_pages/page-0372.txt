14.3 Interval trees                                                                351


I NTERVAL -S EARCH .T; i/
1 x D T:root
2 while x ¤ T:nil and i does not overlap x:int
3      if x:left ¤ T:nil and x:left:max  i:low
4           x D x:left
5      else x D x:right
6 return x

The search for an interval that overlaps i starts with x at the root of the tree and
proceeds downward. It terminates when either it ﬁnds an overlapping interval or x
points to the sentinel T:nil. Since each iteration of the basic loop takes O.1/ time,
and since the height of an n-node red-black tree is O.lg n/, the I NTERVAL -S EARCH
procedure takes O.lg n/ time.
   Before we see why I NTERVAL -S EARCH is correct, let’s examine how it works
on the interval tree in Figure 14.4. Suppose we wish to ﬁnd an interval that overlaps
the interval i D Œ22; 25. We begin with x as the root, which contains Œ16; 21 and
does not overlap i. Since x:left:max D 23 is greater than i:low D 22, the loop
continues with x as the left child of the root—the node containing Œ8; 9, which also
does not overlap i. This time, x:left:max D 10 is less than i:low D 22, and so the
loop continues with the right child of x as the new x. Because the interval Œ15; 23
stored in this node overlaps i, the procedure returns this node.
   As an example of an unsuccessful search, suppose we wish to ﬁnd an interval
that overlaps i D Œ11; 14 in the interval tree of Figure 14.4. We once again be-
gin with x as the root. Since the root’s interval Œ16; 21 does not overlap i, and
since x:left:max D 23 is greater than i:low D 11, we go left to the node con-
taining Œ8; 9. Interval Œ8; 9 does not overlap i, and x:left:max D 10 is less than
i:low D 11, and so we go right. (Note that no interval in the left subtree over-
laps i.) Interval Œ15; 23 does not overlap i, and its left child is T:nil, so again we
go right, the loop terminates, and we return the sentinel T:nil.
   To see why I NTERVAL -S EARCH is correct, we must understand why it sufﬁces
to examine a single path from the root. The basic idea is that at any node x,
if x:int does not overlap i, the search always proceeds in a safe direction: the
search will deﬁnitely ﬁnd an overlapping interval if the tree contains one. The
following theorem states this property more precisely.

Theorem 14.2
Any execution of I NTERVAL -S EARCH .T; i/ either returns a node whose interval
overlaps i, or it returns T:nil and the tree T contains no node whose interval over-
laps i.
