           Problems for Chapter 31                                                        981




Problems

           31-1 Binary gcd algorithm
           Most computers can perform the operations of subtraction, testing the parity (odd
           or even) of a binary integer, and halving more quickly than computing remainders.
           This problem investigates the binary gcd algorithm, which avoids the remainder
           computations used in Euclid’s algorithm.

           a. Prove that if a and b are both even, then gcd.a; b/ D 2  gcd.a=2; b=2/.

           b. Prove that if a is odd and b is even, then gcd.a; b/ D gcd.a; b=2/.

           c. Prove that if a and b are both odd, then gcd.a; b/ D gcd..a  b/=2; b/.

           d. Design an efﬁcient binary gcd algorithm for input integers a and b, where
              a  b, that runs in O.lg a/ time. Assume that each subtraction, parity test,
              and halving takes unit time.

           31-2 Analysis of bit operations in Euclid’s algorithm
           a. Consider the ordinary “paper and pencil” algorithm for long division: dividing
              a by b, which yields a quotient q and remainder r. Show that this method
              requires O..1 C lg q/ lg b/ bit operations.

           b. Deﬁne .a; b/ D .1 C lg a/.1 C lg b/. Show that the number of bit operations
              performed by E UCLID in reducing the problem of computing gcd.a; b/ to that
              of computing gcd.b; a mod b/ is at most c. .a; b/  .b; a mod b// for some
              sufﬁciently large constant c > 0.

           c. Show that E UCLID .a; b/ requires O. .a; b// bit operations in general and
              O.ˇ 2 / bit operations when applied to two ˇ-bit inputs.

           31-3 Three algorithms for Fibonacci numbers
           This problem compares the efﬁciency of three methods for computing the nth Fi-
           bonacci number Fn , given n. Assume that the cost of adding, subtracting, or mul-
           tiplying two numbers is O.1/, independent of the size of the numbers.

           a. Show that the running time of the straightforward recursive method for com-
              puting Fn based on recurrence (3.22) is exponential in n. (See, for example, the
              F IB procedure on page 775.)

           b. Show how to compute Fn in O.n/ time using memoization.
